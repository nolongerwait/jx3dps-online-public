import { 获取实际技能数据 } from '../../../通用/通用函数'
import 循环主类类型 from '../main'
import { 循环基础技能数据类型, 技能释放记录结果 } from '../type'

class 技能统一类 {
  模拟循环: Partial<循环主类类型> = {}
  本次释放记录: 技能释放记录结果 = {}
  本次释放延迟: number | 'GCD' = 0

  constructor(模拟循环) {
    this.模拟循环 = 模拟循环
    return
  }

  获取实际GCD(当前技能?: 循环基础技能数据类型) {
    if (!当前技能) {
      return 0
    }
    const 应校验GCD组: string[] = 当前技能?.检测GCD组 || []
    let 最大GCD = 0
    应校验GCD组.forEach((GCD组) => {
      let 实际GCD = 0
      if (GCD组 === '自身') {
        实际GCD = this.模拟循环.GCD组?.[当前技能?.技能名称]
      } else {
        实际GCD = this.模拟循环.GCD组?.[GCD组]
      }
      if (实际GCD > 最大GCD) {
        最大GCD = 实际GCD
      }
    })
    return 最大GCD
  }

  检查GCD(索引, 当前技能?: 循环基础技能数据类型) {
    const 后一个技能 = this.模拟循环?.测试循环?.[索引 + 1]
    let GCD = this.获取实际GCD(当前技能)
    let 等待GCD = 0

    if (this.本次释放延迟) {
      if (this.本次释放延迟 === 'GCD' && 后一个技能) {
        const 后一个技能实际名称 = 获取实际技能数据(后一个技能)?.实际技能名称
        const 当前技能 = this?.模拟循环?.技能基础数据?.find(
          (item) => item?.技能名称 === 后一个技能实际名称,
        )
        if (当前技能 && 当前技能?.技能GCD组) {
          if (当前技能?.技能GCD组 !== ('自身' as any)) {
            const 技能实例 = this?.模拟循环?.技能类实例集合?.[当前技能?.技能名称]
            const 后一个技能GCD = this.模拟循环?.检查GCD?.(当前技能, 技能实例, 索引 + 1) || 0
            等待GCD = 后一个技能GCD
          } else {
            const 再下一个技能实际名称 = 获取实际技能数据(
              this.模拟循环?.测试循环?.[索引 + 2],
            )?.实际技能名称
            const 再下一个技能 = this?.模拟循环?.技能基础数据?.find(
              (item) => item?.技能名称 === 再下一个技能实际名称,
            )
            if (再下一个技能 && 再下一个技能?.技能GCD组 !== ('自身' as any)) {
              const 技能实例 = this?.模拟循环?.技能类实例集合?.[再下一个技能?.技能名称]
              const 后一个技能GCD = this.模拟循环?.检查GCD?.(再下一个技能, 技能实例, 索引 + 2) || 0
              等待GCD = 后一个技能GCD
            }
          }
        }
      } else {
        等待GCD = Number(this.本次释放延迟)
      }
      if (等待GCD) {
        GCD = Math.max(等待GCD, GCD)
      }
    }

    this.本次释放延迟 = 0
    return GCD
  }

  释放前初始化(额外信息) {
    if (额外信息?.延迟) {
      this.本次释放延迟 = 额外信息?.延迟
    }
    // 重置释放记录
    this.本次释放记录 = {}
  }
  触发回复怒气(怒气值, 来源) {
    this.模拟循环.回复怒气?.(怒气值, 来源)
  }
  触发消耗怒气(怒气值, 来源) {
    this.模拟循环.消耗怒气?.(怒气值, 来源)
  }

  触发伤害行为(
    伤害名称,
    伤害次数 = 1,
    额外增益列表: string[] = [],
    触发伤害时间: number | undefined = undefined,
    DOT伤害 = false,
    技能等级 = 1,
  ) {
    this.模拟循环.技能造成伤害?.(伤害名称, 伤害次数, 额外增益列表, 触发伤害时间, DOT伤害, 技能等级)

    this.模拟循环.卸除buff?.({ 名称: '弱点内置CD', 对象: '目标' })
  }

  重置苍雪刀调息时间() {
    // 重置所有苍雪刀技能的CD
    const 苍雪刀技能列表 = ['斩刀', '绝刀', '劫刀', '闪刀']

    苍雪刀技能列表.forEach((技能名称) => {
      const 技能实例 = this.模拟循环?.技能类实例集合?.[技能名称]
      技能实例?.重置调息时间?.()
    })
  }

  重置盾压调息时间() {
    // 重置盾压调息时间
    const 盾压技能名称 = '盾压'
    const 技能实例 = this.模拟循环?.技能类实例集合?.[盾压技能名称]
    技能实例?.重置调息时间?.()
  }
  绝刀怒气增伤() {
    const 当前怒气 = this.模拟循环.角色状态信息?.怒气 || 0
    const 消耗怒气 = Math.min(Math.floor(当前怒气 / 10) * 10, 50) // 10/20/30/40/50点
    const 有嗜血 = this.模拟循环.校验奇穴是否存在?.('嗜血')
    let 绝刀等级 = 消耗怒气 / 10 // 1-5级对应10-50怒
    if (有嗜血 && 消耗怒气 === 50) {
      绝刀等级 = 7 // 嗜血满怒绝刀特殊等级
    }

    const 绝刀怒气增伤 = 绝刀等级
    const 绝破等级 = Math.min(绝刀等级, 5)

    // 计算绝返等级，用于匹配增益效果
    const 绝返等级 = 消耗怒气 / 10 // 1-5级对应10-50怒气消耗

    return { 消耗怒气, 绝刀等级, 绝刀怒气增伤, 绝破等级, 绝返等级 }
  }
  触发血誓效果() {
    // 检查是否拥有血怒或血怒·惊涌buff
    const 怒气信息 = this.绝刀怒气增伤()
    // 使用统一的绝刀技能，但通过倍率调整伤害，并添加绝返增益
    const 有血怒 = (this.模拟循环.当前自身buff列表?.['血怒']?.当前层数 ?? 0) > 0
    const 有血怒惊涌 = (this.模拟循环.当前自身buff列表?.['血怒_惊涌']?.当前层数 ?? 0) > 0
    if (有血怒 || 有血怒惊涌) {
      const 血誓层数 = this.模拟循环.当前目标buff列表?.['以血盟誓']?.当前层数 || 0
      if (!血誓层数 || 血誓层数 === 1) {
        this.模拟循环.添加buff?.({ 名称: '以血盟誓', 对象: '目标', 新增层数: 1 })
      } else if (血誓层数 === 2) {
        this.模拟循环.卸除buff?.({ 名称: '以血盟誓', 对象: '目标', 卸除层数: 2 })
        this.触发伤害行为('血誓', 1, [`绝返·${怒气信息.绝返等级}`], undefined, false, 1)
      }
    }
  }
  获取技能释放记录结果() {
    return {
      ...this.本次释放记录,
    }
  }

  获取当前重要buff列表(技能依赖自身buff列表: string[] = [], 技能依赖目标buff列表: string[] = []) {
    const 重要buff列表: string[] = []
    技能依赖自身buff列表.forEach((buff) => {
      if (this.模拟循环.当前自身buff列表?.[buff]?.当前层数) {
        重要buff列表.push(buff)
      }
    })
    技能依赖目标buff列表.forEach((buff) => {
      if (this.模拟循环.当前目标buff列表?.[buff]?.当前层数) {
        重要buff列表.push(buff)
      }
    })
    return 重要buff列表 || []
  }

  获取施加重要buff信息(buff名称) {
    const 当前时间 = this.模拟循环.当前时间 || 0
    const buff对象 = this.模拟循环.Buff和Dot数据?.[buff名称]

    return buff对象
      ? {
        buff名称: buff名称,
        buff开始时间: 当前时间,
        buff结束时间: 当前时间 + (buff对象?.最大持续时间 || 0),
      }
      : null
  }

  // 弱点击破标记() {
  //   // 标记该技能可以弱点击破
  //   if (this.模拟循环.当前目标buff列表?.['弱点']?.当前层数) {
  //     this.模拟循环.添加buff?.({ 名称: '可击破', 对象: '目标' })
  //   }
  // }
}

export default 技能统一类
